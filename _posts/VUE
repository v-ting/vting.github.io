##vuex
state、mutations、actions、getters、modules
state:存放数据状态
mutations：对state进行操作
actions：异步操作
getters：加工state成员给外界 类似计算属性computed
modules：模块化管理，可将上面成员进行模块管理
方法dispatch触发action，action中commit触发mutation，mutation对state进行修改(必须经过mutation，异步操作使用action，同步可跳过action)

##vue路由传参
query：需要用path来引入路由，请求参数在url上类似get请求
params：需要用name来引入路由，请求不在url上类似post请求

##vue3
diff静态标记会变的dom 静态提升渲染时不变的创建一次以后复用 监听缓存事件缓存复用

##vue组件通信
props:父组件传子组件,父template中子组件上传参数,子组件data中props接受参数
$emit:子组件传父组件，子组件$emit绑定一个事件并附带参数，父组件定义<em>事件</em>获取参数


##数据响应
#vue2中对象内部通过defineReactive，使用Object.defineProperty将属性进行劫持，数值重写数组方法
实现原理：
let state = { count: 0 };
let active;
// 变成响应式数据
function defineReactive(obj) {
  for (let key in obj) {
    let value = obj[key];
    let dep = [];
    Object.defineProperty(obj, key, {
      get() {
        if (active) {
          dep.push(active); //依赖收集
        }
        return value;
      },
      set(newValue) {
        value = newValue;
        dep.forEach(watcher => watcher()); //触发更新
      }
    });
  }
}
defineReactive(state);
const watcher = fn => {
  active = fn;
  fn();
  active = null;
};
watcher(() => {
  spanName.innerHTML = state.count;
});
inpName.oninput = function() {
  state.count = this.value;
};
#vue3将原来的Object.defineProperty 的getter和setter改变成了Proxy
